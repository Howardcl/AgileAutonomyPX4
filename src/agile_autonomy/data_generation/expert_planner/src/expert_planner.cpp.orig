#include "expert_planner/expert_planner.h"

#include <glog/logging.h>
#include <stdio.h>
#include <experimental/filesystem>
#include <iomanip>
#include <string>

#include "minimum_jerk_trajectories/RapidTrajectoryGenerator.h"
#include "plan_and_stuff_utils/generate_reference.h"
#include "quadrotor_common/parameter_helper.h"
#include "quadrotor_common/trajectory_point.h"
#include "std_msgs/Int32.h"
#include "tf/transform_listener.h"
#include "trajectory_generation_helper/acrobatic_sequence.h"

// Eigen
#include <Eigen/Dense>
#include <opencv2/core.hpp>

namespace expert_planner {

ExpertPlanner::ExpertPlanner(const ros::NodeHandle& nh,
                             const ros::NodeHandle& pnh)
    : nh_(nh), pnh_(pnh) {
  if (!loadParameters()) {
    ROS_ERROR("[%s] Failed to load all parameters",
              ros::this_node::getName().c_str());
    ros::shutdown();
  }

  visualizer_ =
      std::make_shared<visualizer::Visualizer>(nh_, pnh_, "expert_planner");

  // Subscribers
  toggle_experiment_sub_ =
      nh_.subscribe("fpv_quad_looping/execute_trajectory", 1,
                    &ExpertPlanner::startExecutionCallback, this);
  odometry_sub_ = nh_.subscribe("ground_truth/odometry", 1,
                                &ExpertPlanner::odometryCallback, this,
                                ros::TransportHints().tcpNoDelay());
  setup_logging_sub_ =
      nh_.subscribe("save_pc", 1, &ExpertPlanner::setupLoggingCallback, this);
  traj_sub_ = nh_.subscribe("trajectory_predicted", 1,
                            &ExpertPlanner::trajectoryCallback, this);
  traj_fast_planner_sub_ =
      nh_.subscribe("fast_planner_trajectory_predicted", 1,
                    &ExpertPlanner::fastPlannerTrajectoryCallback, this);
  fast_planner_cmd_sub_ = nh_.subscribe(
      "fast_planner_cmd", 1, &ExpertPlanner::fastPlannerCommandCallback, this);
  florence_traj_sub_ =
      nh_.subscribe("florence_trajectory_predicted", 1,
                    &ExpertPlanner::florenceTrajectoryCallback, this);
  start_flying_sub_ = pnh_.subscribe("start_flying", 1,
                                     &ExpertPlanner::stopFlyingCallback, this);
  land_sub_ =
      nh_.subscribe("autopilot/land", 1, &ExpertPlanner::landCallback, this);
  off_sub_ =
      nh_.subscribe("autopilot/off", 1, &ExpertPlanner::offCallback, this);
  force_hover_sub_ = nh_.subscribe("autopilot/force_hover", 1,
                                   &ExpertPlanner::forceHoverCallback, this);
  completed_global_plan_sub_ =
      nh_.subscribe("completed_global_plan", 1,
                    &ExpertPlanner::completedGlobalPlanCallback, this);
  // Publishers
  control_command_pub_ = nh_.advertise<quadrotor_msgs::ControlCommand>(
      "autopilot/control_command_input", 1);
  start_flying_pub_ = pnh_.advertise<std_msgs::Bool>("start_flying", 1);
  ref_progress_pub_ = pnh_.advertise<std_msgs::Int32>("reference_progress", 1);
  goal_pub_ = pnh_.advertise<nav_msgs::Odometry>("goal", 1);
  setpoint_pub_ =
      pnh_.advertise<quadrotor_msgs::TrajectoryPoint>("setpoint", 1);
  compute_global_path_pub_ =
      pnh_.advertise<std_msgs::Bool>("compute_global_plan", 1);

  // Saving timer
  save_timer_ = nh_.createTimer(ros::Duration(1.0 / save_freq_),
                                &ExpertPlanner::saveLoop, this);

  sample_times_.clear();
  for (unsigned int i = 0; i <= traj_len_; i++) {
    sample_times_.push_back(traj_dt_ * i);
  }
  fine_sample_times_.clear();
  for (unsigned int i = 0; i <= static_cast<int>(traj_len_ * traj_dt_ * 50);
       i++) {
    fine_sample_times_.push_back(0.02 * i);
  }

  if (!real_world_exp_) {
    flightmare_bridge_ =
        std::make_shared<flightmare_bridge::FlightmareBridge>(nh_, pnh_);
    unity_is_ready_ = true;
  }
}

ExpertPlanner::~ExpertPlanner() { flightmare_bridge_->disconnect(); }

void ExpertPlanner::startExecutionCallback(const std_msgs::BoolConstPtr& msg) {
  ROS_INFO("Received startExecutionCallback message!");
  computeManeuver(msg->data);
}

void ExpertPlanner::setupLoggingCallback(const std_msgs::BoolConstPtr& msg) {
  if (msg->data) {
    ROS_INFO(
        "Initiated Logging, computing reference trajectory and generating "
        "point cloud!");
    computeManeuver(false);
  }
}

void ExpertPlanner::stopFlyingCallback(const std_msgs::BoolConstPtr& msg) {
  // we finished trajectory execution, close the log file
  if (!msg->data && state_machine_ != StateMachine::kComputeLabels) {
    logging_helper_.closeOdometryLog();
    frame_counter_ = 0;
    reference_progress_abs_ = 0;
    ROS_INFO("Switching to kComputeLabels");
    network_prediction_.clear();
    base_controller_.off();
    visualizer_->clearBuffers();
    state_machine_ = StateMachine::kComputeLabels;
  }
}

void ExpertPlanner::landCallback(const std_msgs::EmptyConstPtr& msg) {
  ROS_INFO("Received land command, stopping maneuver execution!");
  ROS_INFO("Switching to kOff");
  network_prediction_.clear();
  base_controller_.off();
  visualizer_->clearBuffers();
  state_machine_ = StateMachine::kOff;
}

void ExpertPlanner::offCallback(const std_msgs::EmptyConstPtr& msg) {
  ROS_INFO("Received off command, stopping maneuver execution!");
  ROS_INFO("Switching to kOff");
  reference_progress_abs_ = 0;
  network_prediction_.clear();
  base_controller_.off();
  visualizer_->clearBuffers();
  state_machine_ = StateMachine::kOff;
}

void ExpertPlanner::forceHoverCallback(const std_msgs::EmptyConstPtr& msg) {
  ROS_INFO("Received force hover command, stopping maneuver execution!");
  ROS_INFO("Switching to kOff");
  state_machine_ = StateMachine::kOff;
}

void ExpertPlanner::computeManeuver(const bool only_expert) {
  ros::Time time_start_computation = ros::Time::now();
  ROS_INFO("Starting maneuver computation, maneuver_idx: %d", maneuver_idx_);

  quadrotor_common::TrajectoryPoint start_state;
  {
    std::lock_guard<std::mutex> guard(odom_mtx_);
    start_state.position = received_state_est_.position;
    start_state.velocity =
        received_state_est_.velocity + Eigen::Vector3d::UnitX() * 0.2;
    start_state.acceleration = Eigen::Vector3d::Zero();
  }
  fpv_aggressive_trajectories::AcrobaticSequence acrobatic_sequence(
      start_state);

  bool success = true;
  switch (maneuver_idx_) {
    case -3: {
      // we'll go for a single passthrough!
      // unity will spawn objects starting from the negative bounding box end
      // objects are spawned with the same spacing in all dimensions, so the
      // minimum size of the bounding box is this spacing in all axes
      // for this demonstrator, we will just overwrite the spawning
      // parameters
      Eigen::Vector2d gap_location;
      flightmare_bridge_->setupGap(gap_location);

      // some speedup is needed for minjerk to behave nicely
      Eigen::Vector3d end_position_1 =
          Eigen::Vector3d(start_state.position.x() + maneuver_velocity_ / 2.0,
                          start_state.position.y(), start_state.position.z());
      Eigen::Vector3d end_velocity_1 =
          Eigen::Vector3d(maneuver_velocity_, 0.0, 0.0);
      acrobatic_sequence.appendStraight(end_position_1, end_velocity_1, 0.0,
                                        maneuver_velocity_,
                                        traj_sampling_freq_);
      // this is the minimum jerk trajectory that banks through the passthrough
      quadrotor_common::TrajectoryPoint end_state;
      end_state.position =
          Eigen::Vector3d(start_state.position.x() + gap_location.x(),
                          start_state.position.y() + gap_location.y(),
                          start_state.position.z());
      end_state.velocity = Eigen::Vector3d(maneuver_velocity_, 0.0, 0.0);
      end_state.acceleration =
          Eigen::Vector3d(0.0, gap_location.y() > 0.0 ? -10.0 : 10.0, 0.0);
      acrobatic_sequence.appendMinJerk(
          end_state,
          (end_state.position - end_position_1).norm() / maneuver_velocity_,
          traj_sampling_freq_);

      quadrotor_common::TrajectoryPoint end_state_2;
      end_state_2.position =
          Eigen::Vector3d(start_state.position.x() + 2.0 * gap_location.x(),
                          start_state.position.y(), start_state.position.z());
      end_state_2.velocity = Eigen::Vector3d(0.0, 0.0, 0.0);
      end_state_2.acceleration = Eigen::Vector3d(0.0, 0.0, 0.0);
      acrobatic_sequence.appendMinJerk(
          end_state_2,
          (end_state_2.position - end_state.position).norm() /
              maneuver_velocity_,
          traj_sampling_freq_);
      break;
    }
    case -2: {
      // very simple maneuver to test pipeline. Fly straight through a gate.
      double end_yaw = 0.0;
      Eigen::Vector3d end_position =
          Eigen::Vector3d(start_state.position.x() + length_straight_,
                          start_state.position.y(), start_state.position.z());
      Eigen::Vector3d end_position_1 =
          Eigen::Vector3d(start_state.position.x() + maneuver_velocity_,
                          start_state.position.y(), start_state.position.z());
      Eigen::Vector3d end_velocity_1 =
          Eigen::Vector3d(maneuver_velocity_, 0.0, 0.0);

      acrobatic_sequence.appendStraight(end_position_1, end_velocity_1, end_yaw,
                                        maneuver_velocity_,
                                        traj_sampling_freq_);
      acrobatic_sequence.appendStraight(end_position, Eigen::Vector3d::Zero(),
                                        end_yaw, maneuver_velocity_,
                                        traj_sampling_freq_);
      break;
    }
    case -1: {
      // non-trivial trajectory in forest
      Eigen::Vector3d offset_circle_from_start = Eigen::Vector3d(
          d_start_center_x_, d_start_center_y_, d_start_center_z_);
      double offset_x = -offset_circle_from_start.x();
      double offset_y = offset_circle_from_start.y();
      double offset_z = -offset_circle_from_start.z();
      Eigen::Vector3d offset_circle_from_end =
          Eigen::Vector3d(offset_x, offset_y,
                          offset_z);  // before was (4.0, 0.0, 0.5)
      success = success && acrobatic_sequence.appendHorizontalCircle(
                               n_loops_, maneuver_velocity_, loop_radius_,
                               offset_circle_from_start, offset_circle_from_end,
                               true, traj_sampling_freq_);
      break;
    }
    case 0: {
      Eigen::Vector3d enter_translation = Eigen::Vector3d(5.0, 0.0, 0.0);
      Eigen::Vector3d exit_translation = Eigen::Vector3d(5.0, 0.0, 0.0);

      success = success && acrobatic_sequence.appendCorkScrew(
                               3, 3.5, 0.75, enter_translation,
                               exit_translation, false, traj_sampling_freq_);
      break;
    }
    case 1: {
      // Eigen::Vector3d offset_circle_from_start = Eigen::Vector3d(
      //     4.0 - start_state.position.x(), 0.0 - start_state.position.y(),
      //     2.5 - start_state.position.z() -
      //         (0.75 - loop_radius_));  // Sum should be (4,0,-0.5)
      Eigen::Vector3d offset_circle_from_start =
          Eigen::Vector3d(d_start_center_x_, 0.0, d_start_center_z_);
      double offset_x = offset_circle_from_start.x();
      double offset_y = 0.0;
      double offset_z = -offset_circle_from_start.z();
      Eigen::Vector3d offset_circle_from_end =
          Eigen::Vector3d(offset_x, offset_y,
                          offset_z);  // before was (4.0, 0.0, 0.5)
      success = success && acrobatic_sequence.appendLoops(
                               n_loops_, maneuver_velocity_, loop_radius_,
                               offset_circle_from_start, offset_circle_from_end,
                               true, traj_sampling_freq_);
      break;
    }
    case 2: {
      success =
          success && acrobatic_sequence.appendSplitS(3.5, traj_sampling_freq_);
      break;
    }
    case 3: {
      success = success && acrobatic_sequence.appendRandomStraight(
                               2.0, traj_sampling_freq_);
      break;
    }
    case 5: {
      // append big fucking loop
      Eigen::Vector3d offset_circle_from_start = Eigen::Vector3d(6.0, 0.0, 0.5);
      Eigen::Vector3d offset_circle_from_end = Eigen::Vector3d(6.0, 0.0, 0.5);

      success =
          success && acrobatic_sequence.appendLoops(
                         1, 6.0, 2.5, offset_circle_from_start,
                         offset_circle_from_end, true, traj_sampling_freq_);
      break;
    }
    case 6: {
      // medium loop
      Eigen::Vector3d offset_circle_from_start = Eigen::Vector3d(4.0, 0.0, 0.0);
      Eigen::Vector3d offset_circle_from_end = Eigen::Vector3d(-1.0, 0.0, 1.5);
      success =
          success && acrobatic_sequence.appendLoops(
                         1, 4.5, 1.5, offset_circle_from_start,
                         offset_circle_from_end, true, traj_sampling_freq_);
      break;
    }
    case 7: {
      // FMA corkscrew
      Eigen::Vector3d enter_translation = Eigen::Vector3d(3.0, 0.0, 0.0);
      Eigen::Vector3d exit_translation = Eigen::Vector3d(1.0, 0.0, 1.0);
      success = success && acrobatic_sequence.appendCorkScrew(
                               2, 4.5, 1.5, enter_translation, exit_translation,
                               true, traj_sampling_freq_);
      break;
    }
    case 8: {
      // FMA Matty Loop
      Eigen::Vector3d offset_circle_from_start = Eigen::Vector3d(4.0, 0.0, 0.0);
      Eigen::Vector3d offset_circle_from_end = Eigen::Vector3d(-1.0, 0.0, 1.5);
      success = success && acrobatic_sequence.appendCrazyLoop(
                               1, 4.5, 1.5, -M_PI / 2.0, -2 * M_PI, -M_PI,
                               -2 * M_PI, -M_PI / 2.0, offset_circle_from_start,
                               offset_circle_from_end, traj_sampling_freq_);
      break;
    }
    case 9: {
      // Actual FMA matty loop
      // medium loop
      Eigen::Vector3d offset_circle_from_start = Eigen::Vector3d(4.0, 0.0, 0.0);
      Eigen::Vector3d offset_circle_from_end = Eigen::Vector3d(-1.0, 0.0, 1.5);
      success = success && acrobatic_sequence.appendMattyLoop(
                               1, 4.5, 1.5, offset_circle_from_start,
                               offset_circle_from_end, traj_sampling_freq_);
      break;
    }
    case 10: {
      // Combo maneuver
      // first cork screw
      Eigen::Vector3d enter_translation = Eigen::Vector3d(5.0, 0.0, 0.0);
      Eigen::Vector3d exit_translation = Eigen::Vector3d(5.0, 0.0, 0.0);
      success = success && acrobatic_sequence.appendCorkScrew(
                               3, 5.0, 1.5, enter_translation, exit_translation,
                               false, traj_sampling_freq_);
      // then power loop
      Eigen::Vector3d offset_circle_from_start =
          Eigen::Vector3d(4.0, 0.0, -0.5);
      Eigen::Vector3d offset_circle_from_end = Eigen::Vector3d(4.0, 0.0, 0.5);
      success =
          success && acrobatic_sequence.appendLoops(
                         2, 5.0, 1.5, offset_circle_from_start,
                         offset_circle_from_end, false, traj_sampling_freq_);
      // then matty loop
      Eigen::Vector3d offset_matty_start = Eigen::Vector3d(4.0, 0.0, -0.5);
      Eigen::Vector3d offset_matty_end = Eigen::Vector3d(4.0, 0.0, 0.5);
      success = success && acrobatic_sequence.appendMattyLoop(
                               1, 5.0, 1.5, offset_matty_start,
                               offset_matty_end, traj_sampling_freq_);
      break;
    }
    default: {
      ROS_ERROR("Unknown maneuver index: %d", maneuver_idx_);
    }
  }

  visualizer_->visualizeTrajectories(acrobatic_sequence.getManeuverList());

  acrobatic_trajectory_.points.clear();
  fuseTrajectories(acrobatic_sequence.getManeuverList(),
                   &acrobatic_trajectory_);
  acrobatic_trajectory_ext_ =
      TrajectoryPlus(acrobatic_trajectory_, FrameID::World,
                     acrobatic_trajectory_.points.front());

  if (success) {
    // create directory
    logging_helper_.createDirectories(data_dir_, &curr_data_dir_);

    if (!real_world_exp_) {
      // spawns both trees and objects, depending on the params set
      flightmare_bridge_->spawnObjects(start_state);
      flightmare_bridge_->randomizeIllumination();
      // save unity point cloud, adapt point cloud size to maneuver
      Eigen::Vector3d max_corner =
          Eigen::Vector3d::Ones() * std::numeric_limits<double>::min();
      Eigen::Vector3d min_corner =
          Eigen::Vector3d::Ones() * std::numeric_limits<double>::max();

      for (auto point : acrobatic_trajectory_.points) {
        min_corner[0] = std::min(min_corner[0], point.position.x());
        min_corner[1] = std::min(min_corner[1], point.position.y());
        min_corner[2] = std::min(min_corner[2], point.position.z());
        max_corner[0] = std::max(max_corner[0], point.position.x());
        max_corner[1] = std::max(max_corner[1], point.position.y());
        max_corner[2] = std::max(max_corner[2], point.position.z());
      }
      flightmare_bridge_->generatePointcloud(min_corner, max_corner,
                                             curr_data_dir_);
    }

    // open log file
    logging_helper_.newOdometryLog(curr_data_dir_ + "/odometry.csv");
    logging_helper_.saveTrajectorytoCSV(
        curr_data_dir_ + "/reference_trajectory.csv", acrobatic_trajectory_);

    rollout_counter_ += 1;
    reference_progress_abs_ = 0;
    viz_id_ = 10;
    visualizer_->clearBuffers();
    std_msgs::Int32 progress_msg;
    progress_msg.data = reference_progress_abs_;
    ref_progress_pub_.publish(progress_msg);

    time_start_logging_ = ros::Time::now();
    time_start_trajectory_execution_ = ros::Time::now();

    received_network_prediction_ = false;
    network_prediction_.clear();
    reference_ready_ = false;

    if (perform_global_planning_) {
      ROS_INFO(
          "Not yet switching state machine, waiting for global reference to "
          "arrive...");
      only_expert_ = only_expert;
      std_msgs::Bool true_msg;
      true_msg.data = true;
      compute_global_path_pub_.publish(true_msg);
    } else {
      ROS_INFO("Gogogo!");
      if (only_expert) {
        // we only go to kExecuteTrajectory mode if we want to execute expert
        // only else we wait for the first trajectory from the network to arrive
        // before switch to kNetwork mode
        ROS_INFO("Switching to kExecuteExpert");
        state_machine_ = StateMachine::kExecuteExpert;
      } else {
        // setting the state machine to kAutopilot here reallows to switch to
        // network later
        ROS_INFO("Switching to kAutopilot");
        state_machine_ = StateMachine::kAutopilot;
      }
      for (int i = 0; i < 1; i++) {
        std_msgs::Bool bool_msg;
        bool_msg.data = true;
        start_flying_pub_.publish(bool_msg);
        ros::Duration(0.05).sleep();
      }
    }
    ROS_INFO("Maneuver computation successful!");
  } else {
    ROS_ERROR("Maneuver computation failed! Will not execute trajectory.");
  }
  ROS_INFO("Maneuver computation took %.4f seconds.",
           (ros::Time::now() - time_start_computation).toSec());
}

void ExpertPlanner::saveLoop(const ros::TimerEvent& time) {
  // we don't save anything during real world experiments
  if (real_world_exp_) return;
  // if inputs are ok and unity is ready, we compute & publish depth
  if (unity_is_ready_ && received_state_est_.isValid()) {
    quadrotor_common::QuadStateEstimate temp_state_estimate;
    {
      std::lock_guard<std::mutex> guard(odom_mtx_);
      temp_state_estimate = received_state_est_;
    }
    quadrotor_common::TrajectoryPoint temp_reference;
    {
      std::lock_guard<std::mutex> guard(curr_ref_mtx_);
      temp_reference = curr_reference_;
    }
    std::ostringstream ss;
    ss << std::setw(8) << std::setfill('0') << frame_counter_;
    std::string s2(ss.str());

    // save data to disk
    if (state_machine_ == StateMachine::kExecuteExpert ||
        state_machine_ == StateMachine::kNetwork) {
      if (!logging_helper_.logOdometry(
              temp_state_estimate, temp_reference, time_start_logging_,
              reference_progress_abs_, cam_pitch_angle_)) {
        // log file not yet ready!
        flightmare_bridge_->getImages(temp_state_estimate, "", 0);
        return;
      }

      // we also save the network predictions to file
      if (save_network_trajectories_ && received_network_prediction_) {
        ros::WallTime t_start_log = ros::WallTime::now();
        std::string csv_filename_wf =
            curr_data_dir_ + "/trajectories/trajectories_nw_wf_" + s2 + ".csv";

        logging_helper_.save_nw_pred_to_csv(network_prediction_,
                                            csv_filename_wf);
      }

      flightmare_bridge_->getImages(temp_state_estimate, curr_data_dir_,
                                    frame_counter_);
      frame_counter_ += 1;
    } else {
      // we don't save data but would like to see the images in RViz
      flightmare_bridge_->getImages(temp_state_estimate, "", 0);
    }
  }
}

double ExpertPlanner::yawFromQuaternion(const Eigen::Quaterniond& q) {
  Eigen::Vector3d body_x_world = q * Eigen::Vector3d::UnitX();
  body_x_world[2] = 0.0;
  body_x_world.normalize();
  double yaw = std::atan2(body_x_world.y(), body_x_world.x());
  return yaw;
}

bool ExpertPlanner::convertTrajectoriesToWorldFrame(
    const std::vector<quadrotor_common::Trajectory>& nw_trajectories,
    const rpg::Pose& T_W_S, const TrajectoryPlus& prev_ref,
    std::vector<quadrotor_common::Trajectory>* world_trajectories,
    std::vector<double>* trajectory_costs) {
  int i = 1;
  for (auto trajectory : nw_trajectories) {
    world_trajectories->push_back(quadrotor_common::Trajectory());
    trajectory_costs->push_back(0.0);
    int point_idx = 0;
    for (auto point : trajectory.points) {
      // transform position to world frame
      rpg::Pose T_S_C =
          rpg::Pose(point.position, Eigen::Quaterniond::Identity());
      rpg::Pose T_W_C = T_W_S * T_S_C;

      // collect transformed trajectory points in reference trajectory
      quadrotor_common::TrajectoryPoint world_point;
      world_point.time_from_start = point.time_from_start;
      world_point.position = T_W_C.getPosition();
      world_point.position[2] =
          std::min(world_point.position[2], test_time_max_z_);
      world_trajectories->back().points.push_back(world_point);
      if (reference_ready_) {
        point_idx = std::min(point_idx,
                             static_cast<int>(prev_ref.getPoints().size() - 1));
        trajectory_costs->back() +=
            (world_point.position -
             prev_ref.getPoints()
                 .at(std::min(
                     point_idx,
                     static_cast<int>(prev_ref.getPoints().size()) - 1))
                 .position)
                .norm();
      }
      point_idx++;
    }
    visualizer_->visualizeTrajectory(world_trajectories->back(),
                                     "raw_nw_prediction", viz_id_ + i * 1000,
                                     1.0, 1.0, 1.0, 0.5);
    i++;
  }
  return true;
}

bool ExpertPlanner::computeMinJerk(
    const std::vector<quadrotor_common::Trajectory>& nw_trajectories,
    const rpg::Pose& T_W_S, const TrajectoryPlus& prev_ref,
    std::vector<quadrotor_common::Trajectory>* world_trajectories,
    std::vector<double>* trajectory_costs) {
  ROS_INFO("Computing minimum jerk trajectory! End pos: [%.2f, %.2f, %.2f]",
           nw_trajectories.front().points.front().position.x(),
           nw_trajectories.front().points.front().position.y(),
           nw_trajectories.front().points.front().position.z());
  int i = 1;
  for (auto nw_trajectory : nw_trajectories) {
    rpg::Pose T_S_C = rpg::Pose(nw_trajectory.points.front().position,
                                Eigen::Quaterniond::Identity());
    rpg::Pose T_W_C = T_W_S * T_S_C;

    // compute a minjerk trajectory from the current reference to this point
    // set the duration equal to the euclidean distance divided by the desired
    // test time speed
    Vec3 pos0, vel0, acc0;
    if (reference_ready_) {
      std::lock_guard<std::mutex> guard(curr_ref_mtx_);
      pos0 = Vec3(curr_reference_.position.x(), curr_reference_.position.y(),
                  curr_reference_.position.z());
      vel0 = Vec3(curr_reference_.velocity.x(), curr_reference_.velocity.y(),
                  curr_reference_.velocity.z());
      acc0 = Vec3(curr_reference_.acceleration.x(),
                  curr_reference_.acceleration.y(),
                  curr_reference_.acceleration.z());
    } else {
      std::lock_guard<std::mutex> guard(odom_mtx_);
      pos0 = Vec3(received_state_est_.position.x(),
                  received_state_est_.position.y(),
                  received_state_est_.position.z());
      vel0 = Vec3(received_state_est_.velocity.x(),
                  received_state_est_.velocity.y(),
                  received_state_est_.velocity.z());
      acc0 = Vec3(0.0, 0.0, 0.0);
    }

    // Define how gravity lies in our coordinate system
    Vec3 gravity = Vec3(0, 0, -9.81);  //[m/s**2]

    minimum_jerk_trajectories::RapidTrajectoryGenerator traj =
        minimum_jerk_trajectories::RapidTrajectoryGenerator(pos0, vel0, acc0,
                                                            gravity);

    Vec3 posf = Vec3(T_W_C.getPosition().x(), T_W_C.getPosition().y(),
                     T_W_C.getPosition().z());
    //  Vec3 velf =
    //      Vec3(end_state.velocity(0), end_state.velocity(1),
    //      end_state.velocity(2));
    //  Vec3 accf = Vec3(end_state.acceleration(0), end_state.acceleration(1),
    //                   end_state.acceleration(2));

    traj.SetGoalPosition(posf);
    //  traj.SetGoalVelocity(velf);
    //  traj.SetGoalAcceleration(accf);
    double desired_speed =  // avg_velocity;
        std::min(vel0.GetNorm2() + 1.0, test_time_velocity_);
    double duration = (T_W_C.getPosition() - T_W_S.getPosition()).norm() /
                      desired_speed;  // TODO
    duration = std::max(duration, traj_dt_ * traj_len_);
    traj.Generate(duration);  // last point is 1 second in the future

    double traj_sampling_freq = 50.0;
    double min_normalized_thrust = 2.0;
    double max_normalized_thrust = 20.0;
    double max_roll_pitch_rate = 6.9;
    double min_traj_sampling_time = 1.0 / traj_sampling_freq;
    bool success = true;
    minimum_jerk_trajectories::RapidTrajectoryGenerator::InputFeasibilityResult
        res = traj.CheckInputFeasibility(
            min_normalized_thrust, max_normalized_thrust, max_roll_pitch_rate,
            min_traj_sampling_time);
    //    if (res ==
    //        minimum_jerk_trajectories::RapidTrajectoryGenerator::InputFeasible)
    //        {
    //      // check also for floor/ceiling feasibility
    //      Vec3 boundary_point = Vec3(0.0, 0.0, 0.0);  // a point on the floor
    //      Vec3 boundary_normal =
    //          Vec3(0.0, 0.0,
    //               1.0);  // we want to be in this direction of the point
    //               (upwards)
    //      minimum_jerk_trajectories::RapidTrajectoryGenerator::
    //          StateFeasibilityResult positionFeasible_floor =
    //              traj.CheckPositionFeasibility(boundary_point,
    //              boundary_normal);
    //      if (positionFeasible_floor ==
    //          minimum_jerk_trajectories::RapidTrajectoryGenerator::StateFeasible)
    //          {
    //        success = true;
    //      }
    //    } else {
    //      //    ROS_WARN("[%s] Trajectory not input feasible.",
    //      //             ros::this_node::getName().c_str());
    //    }

    if (!success) {
      ROS_WARN("[%s] Failed to calculate trajectory.",
               ros::this_node::getName().c_str());
      ROS_WARN("[%s] Start: [%f, %f, %f].", ros::this_node::getName().c_str(),
               pos0.x, pos0.y, pos0.z);
      ROS_WARN("[%s] End: [%f, %f, %f].", ros::this_node::getName().c_str(),
               posf.x, posf.y, posf.z);
      return false;
    }

    world_trajectories->push_back(quadrotor_common::Trajectory());
    trajectory_costs->push_back(0.0);
    int point_idx = 0;
    double traj_t = 0.0;
    for (int i = 0; i <= traj_len_; i++) {
      // collect transformed trajectory points in reference trajectory
      quadrotor_common::TrajectoryPoint world_point;
      world_point.time_from_start = ros::Duration(i * traj_dt_);
      world_point.position = Eigen::Vector3d(traj.GetPosition(i * traj_dt_).x,
                                             traj.GetPosition(i * traj_dt_).y,
                                             traj.GetPosition(i * traj_dt_).z);
      world_point.position[2] =
          std::min(world_point.position[2], test_time_max_z_);
      world_point.velocity = Eigen::Vector3d(traj.GetVelocity(i * traj_dt_).x,
                                             traj.GetVelocity(i * traj_dt_).y,
                                             traj.GetVelocity(i * traj_dt_).z);
      world_point.acceleration =
          Eigen::Vector3d(traj.GetAcceleration(i * traj_dt_).x,
                          traj.GetAcceleration(i * traj_dt_).y,
                          traj.GetAcceleration(i * traj_dt_).z);
      world_point.jerk = Eigen::Vector3d(traj.GetJerk(i * traj_dt_).x,
                                         traj.GetJerk(i * traj_dt_).y,
                                         traj.GetJerk(i * traj_dt_).z);

      // TODO: add attitude, bodyrates
      // Attitude
      //      Eigen::Vector3d thrust =
      //          world_point.acceleration + 9.81 * Eigen::Vector3d::UnitZ();
      //      Eigen::Vector3d I_eZ_I(0.0, 0.0, 1.0);
      //      Eigen::Quaterniond q_pitch_roll =
      //          Eigen::Quaterniond::FromTwoVectors(I_eZ_I, thrust);
      //
      //      Eigen::Vector3d linvel_body =
      //          q_pitch_roll.inverse() * world_point.velocity;
      //      double heading = 0.0;
      //      if (yawing_enabled_) {
      //        //      heading = std::atan2(linvel_body.y(), linvel_body.x());
      //        heading =
      //            std::atan2(world_point.velocity.y(),
      //            world_point.velocity.x());
      //      }
      //
      //      Eigen::Quaterniond q_heading = Eigen::Quaterniond(
      //          Eigen::AngleAxisd(heading, Eigen::Vector3d::UnitZ()));
      //      Eigen::Quaterniond q_att = q_pitch_roll * q_heading;
      //      q_att.normalize();
      //      world_point.orientation = q_att;

      // to compute the bodyrates, use numeric differentiation
      const double delta_t = 0.001;
      const Eigen::Vector3d thrust_before = world_point.acceleration -
                                            world_point.jerk * delta_t +
                                            9.81 * Eigen::Vector3d::UnitZ();
      const Eigen::Vector3d thrust_after = world_point.acceleration +
                                           world_point.jerk * delta_t +
                                           9.81 * Eigen::Vector3d::UnitZ();
      const Eigen::Vector3d thrust =
          world_point.acceleration + 9.81 * Eigen::Vector3d::UnitZ();
      Eigen::Quaterniond q_pitch_roll =
          Eigen::Quaterniond::FromTwoVectors(Eigen::Vector3d::UnitZ(), thrust);

      const Eigen::Quaterniond q_pitch_roll_before =
          Eigen::Quaterniond::FromTwoVectors(Eigen::Vector3d::UnitZ(),
                                             thrust_before);
      const Eigen::Quaterniond q_pitch_roll_after =
          Eigen::Quaterniond::FromTwoVectors(Eigen::Vector3d::UnitZ(),
                                             thrust_after);

      double yaw;
      if (false) {
        // use a fixed heading along the polynomial
        yaw = 0.0;
      } else {
        // if no heading is specified, use forward heading
        const Eigen::Vector3d v_body =
            q_pitch_roll.inverse() * world_point.velocity;
        if ((v_body.x() * v_body.x() + v_body.y() * v_body.y()) < 1e-6) {
          yaw = 0.0;
        } else {
          yaw = std::atan2(v_body.y(), v_body.x());
        }
      }

      const Eigen::Quaterniond q_heading = Eigen::Quaterniond(
          Eigen::AngleAxis<double>(yaw, Eigen::Vector3d::UnitZ()));
      const Eigen::Quaterniond q_att = q_pitch_roll * q_heading;
      world_point.orientation = q_att;

      const Eigen::Quaterniond q_before = q_pitch_roll_before * q_heading;
      const Eigen::Quaterniond q_after = q_pitch_roll_after * q_heading;
      // compute bodyrates
      const Eigen::Quaterniond q_omega = q_before.inverse() * q_after;
      world_point.bodyrates[0] = 1.0 / delta_t * q_omega.x();
      world_point.bodyrates[1] = 1.0 / delta_t * q_omega.y();
      world_point.bodyrates[2] = 1.0 / delta_t * q_omega.z();

      world_trajectories->back().points.push_back(world_point);
      point_idx++;
    }
    visualizer_->visualizeTrajectory(world_trajectories->back(),
                                     "raw_nw_prediction", viz_id_ + i * 1000,
                                     1.0, 1.0, 1.0, 0.5);
    i++;
  }
  return true;
}

/// converts a stacked network prediction in bodyframe to a single selected
/// trajectory in world frame
bool ExpertPlanner::selectBestNetworkPrediction(
    const std::vector<quadrotor_common::Trajectory>& nw_trajectories,
    const Eigen::Vector3d& start_pos, const Eigen::Quaterniond& start_att,
    quadrotor_common::Trajectory* const selected_trajectory) {
  selected_trajectory->points.clear();

  rpg::Pose T_W_S;
  switch (nw_predictions_frame_id_) {
    case FrameID::Body: {
      T_W_S = rpg::Pose(start_pos, start_att);
      break;
    }
    case FrameID::GravityAligned: {
      double yaw = yawFromQuaternion(start_att);
      Eigen::Quaterniond q_ga = Eigen::Quaterniond(std::cos(yaw / 2.0), 0.0,
                                                   0.0, std::sin(yaw / 2.0));
      T_W_S = rpg::Pose(start_pos, q_ga);
      break;
    }
    default: {
      ROS_ERROR("Unsupported network reference frame.");
    }
  }

  // we use the previous reference to decide which NW trajectory to execute
  // (i.e. minimize the control cost)
  TrajectoryPlus prev_ref;
  if (reference_ready_) {
    std::lock_guard<std::mutex> guard(curr_ref_mtx_);
    prev_ref = TrajectoryPlus(prev_ref_traj_, FrameID::World,
                              prev_ref_traj_.points.front());
  }

  // convert the trajectories to world frame
  std::vector<quadrotor_common::Trajectory> world_trajectories;
  std::vector<double> trajectory_costs;
  if (nw_trajectories.front().points.size() > 1) {
    convertTrajectoriesToWorldFrame(nw_trajectories, T_W_S, prev_ref,
                                    &world_trajectories, &trajectory_costs);
  } else {
    // NW predicted only single point, so we'll compute a minimum jerk
    // trajectory
    min_jerk_mode_ = true;
    computeMinJerk(nw_trajectories, T_W_S, prev_ref, &world_trajectories,
                   &trajectory_costs);
  }

  // extract best trajectory
  int best_traj_idx = 0;
  if (!reference_ready_) {
    best_traj_idx = 0;
  } else {
    best_traj_idx =
        std::min_element(trajectory_costs.begin(), trajectory_costs.end()) -
        trajectory_costs.begin();
  }
  ROS_INFO("Selected trajectory #%d", best_traj_idx);
  if (best_traj_idx >= world_trajectories.size()) {
    ROS_ERROR("Selected trajectory is out of bounds! Selecting trajectory #0!");
    best_traj_idx = 0;
  }
  for (auto point : world_trajectories.at(best_traj_idx).points) {
    selected_trajectory->points.push_back(point);
  }

  return true;
}

void ExpertPlanner::trajectoryCallback(
    const plan_and_stuff_msgs::MultiTrajectoryConstPtr& msg) {
  if (state_machine_ == StateMachine::kComputeLabels ||
      state_machine_ == StateMachine::kOff) {
    return;
  }
  pred_traj_idx_++;
  time_received_prediction_ = msg->header.stamp;  // ros::Time::now();
  std::vector<quadrotor_common::Trajectory> nw_trajectories;

  // predicted network trajectories are either in body or gravity-aligned frame
  for (auto trajectory : msg->trajectories) {
    nw_trajectories.push_back(trajectory);
  }

  quadrotor_common::Trajectory traj_pred_world;
  traj_pred_world.trajectory_type =
      quadrotor_common::Trajectory::TrajectoryType::GENERAL;
  quadrotor_common::QuadStateEstimate temp_state_estimate;
  {
    std::lock_guard<std::mutex> guard(odom_mtx_);
    temp_state_estimate = received_state_est_;
  }

  quadrotor_common::QuadStateEstimate odom_at_inference;
  odom_at_inference.position =
      Eigen::Vector3d(msg->ref_pose.position.x, msg->ref_pose.position.y,
                      msg->ref_pose.position.z);
  odom_at_inference.orientation =
      Eigen::Quaterniond(
          msg->ref_pose.orientation.w, msg->ref_pose.orientation.x,
          msg->ref_pose.orientation.y, msg->ref_pose.orientation.z) *
      Eigen::Quaternion(std::cos(-cam_pitch_angle_ / 2.0), 0.0,
                        std::sin(-cam_pitch_angle_ / 2.0), 0.0);
  odom_at_inference.velocity = Eigen::Vector3d(
      msg->ref_vel.linear.x, msg->ref_vel.linear.y, msg->ref_vel.linear.z);

  bool execute_nw = msg->execute;
  selectBestNetworkPrediction(nw_trajectories, odom_at_inference.position,
                              odom_at_inference.orientation, &traj_pred_world);
  double red, green, blue;
  red = 0.0;
  blue = 1.0;
  green = 0.0;
  if (!execute_nw) {
    execute_nw = false;
    red = 1.0;
    blue = 0.0;
  }

  TrajectoryPlus traj_world_ext(traj_pred_world, FrameID::World,
                                traj_pred_world.points.front());

  quadrotor_common::Trajectory network_traj;
  traj_world_ext.getTrajectory(&network_traj);
  //  std::printf("blub time: %.2f\n",
  //  network_traj.points.front().time_from_start.toSec());
  visualizer_->visualizeTrajectory(network_traj, "selected_nw_prediction",
                                   viz_id_, red, green, blue, 1.0);

  if (!min_jerk_mode_) {
    ////////////////
    //  std::printf("Raw avg velocity:     ");
    //  double avg_velocity = 0.0;
    //  for (int i = 0; i < traj_world_ext.getPoints().size() - 1; i++) {
    //    std::printf("%.2f | ", (traj_world_ext.getPoints().at(i + 1).position
    //    -
    //                            traj_world_ext.getPoints().at(i).position)
    //                                   .norm() /
    //                               0.1);
    //    avg_velocity += (traj_world_ext.getPoints().at(i + 1).position -
    //                     traj_world_ext.getPoints().at(i).position)
    //                        .norm() /
    //                    0.1;
    //  }
    //  avg_velocity /= traj_world_ext.getPoints().size() - 1;
    //  std::printf("%.3f", avg_velocity);
    //  std::printf("\n");

    //  std::ostringstream ss;
    //  ss << std::setw(8) << std::setfill('0') << pred_traj_idx_;
    //  std::string s2(ss.str());
    //  std::string csv_filename_wf = "/home/elia/tmp/raw_" + s2 + ".csv";
    //  traj_world_ext.getTrajectory(&network_traj);
    //  logging_helper_.saveTrajectorytoCSV(csv_filename_wf, network_traj);

    ////////////////

    // let's do some fitting adventure...
    // since the constraint is enforced at the first point, we need to remove
    // the first point and replace it with the current state estimate...
    TrajectoryPlusPoint state_est_point;
    if (reference_ready_) {
      std::lock_guard<std::mutex> guard(curr_ref_mtx_);
      state_est_point.time_from_start = 0.0;
      state_est_point.position = curr_reference_.position;
      //    state_est_point.velocity = curr_reference_.velocity;
      //    state_est_point.position = odom_at_inference.position;
      //    state_est_point.position = temp_state_estimate.position;
      state_est_point.velocity = curr_reference_.velocity;
      state_est_point.acceleration = curr_reference_.acceleration;
    } else {
      state_est_point.time_from_start = 0.0;
      state_est_point.position = temp_state_estimate.position;
      state_est_point.velocity = temp_state_estimate.velocity;
      state_est_point.acceleration = Eigen::Vector3d::Zero();
    }
    traj_world_ext.replaceFirstPoint(state_est_point);
    //  traj_world_ext.pushPointFront(state_est_point, traj_dt_);

    //  csv_filename_wf = "/home/elia/tmp/raw2_" + s2 + ".csv";
    //  traj_world_ext.getTrajectory(&network_traj);
    //  logging_helper_.saveTrajectorytoCSV(csv_filename_wf, network_traj);

    double fitting_error = 0.0;
    traj_world_ext.fitPolynomialCoeffs(5, 2, &fitting_error);
    traj_world_ext.enableYawing(enable_yawing_);
    traj_world_ext.resamplePointsFromPolyCoeffs();

    traj_world_ext.getTrajectory(&network_traj);
    //  std::printf("size traj 1: %lu\n", network_traj.points.size());
    visualizer_->visualizeTrajectory(network_traj, "fitted_nw_prediction",
                                     viz_id_, red, 1.0, blue, 1.0);

    double desired_speed;
    ////////////////
    //  csv_filename_wf = "/home/elia/tmp/fitted_" + s2 + ".csv";
    //  traj_world_ext.getTrajectory(&network_traj);
    //  logging_helper_.saveTrajectorytoCSV(csv_filename_wf, network_traj);
    //  std::printf("NW pred velocities: ");
    //  for (auto point : network_traj.points) {
    //    std::printf("%.2f | ", point.velocity.norm());
    //  }
    //  std::printf("\n");
    //  ////////////////
    //  std::printf("Numeric velocities: ");
    //  for (int i = 0; i < traj_world_ext.getPoints().size() - 1; i++) {
    //    std::printf("%.2f | ", (traj_world_ext.getPoints().at(i + 1).position
    //    -
    //                            traj_world_ext.getPoints().at(i).position)
    //                                   .norm() /
    //                               0.1);
    //  }
    //  std::printf("\n");
    ////////////////

    desired_speed =  // avg_velocity;
        std::min(temp_state_estimate.velocity.norm() + 1.0,
                 test_time_velocity_);
    traj_world_ext.setConstantArcLengthSpeed(
        desired_speed, static_cast<int>(traj_len_), traj_dt_);
    traj_world_ext.getTrajectory(&network_traj);
    //  std::printf("size traj 1: %lu\n", network_traj.points.size());
    visualizer_->visualizeTrajectory(network_traj, "arclen_nw_prediction",
                                     viz_id_, red, 1.0, blue, 1.0);
  }
  ////////////////
  //  csv_filename_wf = "/home/elia/tmp/const_" + s2 + ".csv";
  //  traj_world_ext.getTrajectory(&network_traj);
  //  logging_helper_.saveTrajectorytoCSV(csv_filename_wf, network_traj);
  //  std::printf("Const velocities:   ");
  //  for (int i = 0; i < traj_world_ext.getPoints().size() - 1; i++) {
  //    std::printf("%.2f | ", (traj_world_ext.getPoints().at(i + 1).position -
  //                            traj_world_ext.getPoints().at(i).position)
  //                                   .norm() /
  //                               0.1);
  //  }
  //  std::printf("\n");
  ////////////////
  //  std::printf("Curr reference: %.2f, %.2f, %.2f\n",
  //              curr_reference_.position.x(), curr_reference_.position.y(),
  //              curr_reference_.position.z());
  //  std::printf("Curr pos: %.2f, %.2f, %.2f\n",
  //  temp_state_estimate.position.x(),
  //              temp_state_estimate.position.y(),
  //              temp_state_estimate.position.z());
  //  std::printf("First point of traj: %.2f, %.2f, %.2f\n",
  //              traj_world_ext.getPoints().front().position.x(),
  //              traj_world_ext.getPoints().front().position.y(),
  //              traj_world_ext.getPoints().front().position.z());

  // ensure continuity of the tracked reference
  //  traj_world_ext.translate(curr_reference_.position -
  //                           odom_at_inference.position);

  viz_id_ += 1;
  if ((viz_id_ - viz_id_start_) >= num_traj_viz_) {
    viz_id_ = viz_id_start_;
  }

  {
    std::lock_guard<std::mutex> guard(nw_pred_mtx_);
    network_prediction_ = traj_world_ext;
  }
  // go into network mode
  if (execute_nw) {
    state_machine_ = StateMachine::kNetwork;
  } else {
    state_machine_ = StateMachine::kExecuteExpert;
  }
}

void ExpertPlanner::fastPlannerTrajectoryCallback(
    const plan_and_stuff_msgs::BsplineConstPtr& msg) {
  time_received_prediction_ = ros::Time::now();
  quadrotor_common::Trajectory fast_planner_traj;
  int iter = 0;
  for (auto point : msg->pos_pts) {
    quadrotor_common::TrajectoryPoint curr_point;
    curr_point.time_from_start = ros::Duration(
        iter * 0.1);  // I just assume the bspline is sampled at 10Hz
    curr_point.position = Eigen::Vector3d(point.x, point.y, point.z);
    fast_planner_traj.points.push_back(curr_point);
    iter++;
  }
  TrajectoryPlus traj_world_ext(fast_planner_traj, FrameID::World,
                                fast_planner_traj.points.front());
  traj_world_ext.getTrajectory(&fast_planner_traj);
  visualizer_->visualizeTrajectory(fast_planner_traj, "selected_nw_prediction",
                                   viz_id_, 1.0, 0.0, 0.0, 1.0);
  double fitting_error = 0.0;
  traj_world_ext.fitPolynomialCoeffs(5, 2, &fitting_error);
  traj_world_ext.enableYawing(enable_yawing_);
  traj_world_ext.resamplePointsFromPolyCoeffs();

  double desired_speed;
  desired_speed = test_time_velocity_;
  traj_world_ext.setConstantArcLengthSpeed(
      desired_speed, static_cast<int>(traj_len_), traj_dt_);

  traj_world_ext.getTrajectory(&fast_planner_traj);
  visualizer_->visualizeTrajectory(fast_planner_traj, "arclen_nw_prediction",
                                   viz_id_, 0.0, 1.0, 0.0, 1.0);

  // we imitate the network prediction workflow
  {
    std::lock_guard<std::mutex> guard(nw_pred_mtx_);
    network_prediction_ = traj_world_ext;
  }
  state_machine_ = StateMachine::kNetwork;
}

void ExpertPlanner::fastPlannerCommandCallback(
    const plan_and_stuff_msgs::PositionCommandConstPtr& msg) {
  if (state_machine_ == StateMachine::kComputeLabels ||
      state_machine_ == StateMachine::kOff) {
    return;
  }

  // we imitate the network prediction workflow
  quadrotor_common::Trajectory fast_planner_traj;
  quadrotor_common::TrajectoryPoint desired_point;
  desired_point.time_from_start = ros::Duration(0.0);
  desired_point.position =
      Eigen::Vector3d(msg->position.x, msg->position.y, msg->position.z);
  desired_point.orientation = Eigen::Quaterniond(std::cos(msg->yaw / 2.0), 0.0,
                                                 0.0, std::sin(msg->yaw / 2.0));
  desired_point.velocity =
      Eigen::Vector3d(msg->velocity.x, msg->velocity.y, msg->velocity.z);

<<<<<<< HEAD
  quadrotor_common::QuadStateEstimate temp_state_estimate;
  {
    std::lock_guard<std::mutex> guard(odom_mtx_);
    temp_state_estimate = received_state_est_;
  }

  double des_vel_norm = desired_point.velocity.norm();
  double desired_speed = std::min(temp_state_estimate.velocity.norm() + 1.0,
                                  desired_point.velocity.norm());
  desired_point.velocity =
      desired_point.velocity / des_vel_norm * desired_speed;

  ROS_INFO("Desired state | P: %.2f, %.2f, %.2f | V: %.2f, %.2f, %.2f",
           desired_point.position.x(), desired_point.position.y(),
           desired_point.position.z(), desired_point.velocity.x(),
           desired_point.velocity.y(), desired_point.velocity.z());
  fast_planner_traj.points.push_back(desired_point);
  // extrapolate the other points
  for (int i = 1; i < 10; i++) {
    quadrotor_common::TrajectoryPoint extrapolated_point;
    extrapolated_point.time_from_start = ros::Duration(0.1 * i);
    extrapolated_point.position =
        desired_point.position + 0.1 * i * desired_point.velocity;
    extrapolated_point.velocity = desired_point.velocity;
    fast_planner_traj.points.push_back(extrapolated_point);
  }
=======
  ROS_INFO("Received position: %.2f, %.2f, %.2f", desired_point.position.x(),
           desired_point.position.y(), desired_point.position.z());

  // publish a marker to illustrate the desired position
  visualizer_->visualizePosition(desired_point.position);
>>>>>>> 145d5713f712fe006020d711c4f830f38bb83bf6

  // fast planner continues to publish commands when it arrived at the goal
  // location
  if (desired_point.velocity.norm() < 0.01) {
    state_machine_ = StateMachine::kAutopilot;
  }

  TrajectoryPlus traj_world_ext(fast_planner_traj, FrameID::World,
                                fast_planner_traj.points.front());
  {
    std::lock_guard<std::mutex> guard(nw_pred_mtx_);
    network_prediction_ = traj_world_ext;
  }
  state_machine_ = StateMachine::kNetwork;
}

void ExpertPlanner::florenceTrajectoryCallback(
    const quadrotor_msgs::TrajectoryConstPtr& msg) {
  if (state_machine_ == StateMachine::kComputeLabels ||
      state_machine_ == StateMachine::kOff) {
    return;
  }
  time_received_prediction_ = ros::Time::now();

  quadrotor_common::Trajectory traj_pred_world;
  traj_pred_world.trajectory_type =
      quadrotor_common::Trajectory::TrajectoryType::GENERAL;
  quadrotor_common::QuadStateEstimate temp_state_estimate;
  {
    std::lock_guard<std::mutex> guard(odom_mtx_);
    temp_state_estimate = received_state_est_;
  }

  bool execute_nw = msg->points.front().heading_acceleration > 0.0;

  for (auto point : msg->points) {
    point.pose.position.z = std::min(point.pose.position.z, test_time_max_z_);
    traj_pred_world.points.push_back(point);
  }

  double red, green, blue;
  red = 0.0;
  blue = 1.0;
  green = 0.0;
  if (!execute_nw) {
    execute_nw = false;
    red = 1.0;
    blue = 0.0;
  }

  TrajectoryPlus traj_world_ext(traj_pred_world, FrameID::World,
                                traj_pred_world.points.front());

  quadrotor_common::Trajectory network_traj;
  traj_world_ext.getTrajectory(&network_traj);
  visualizer_->visualizeTrajectory(network_traj, "selected_nw_prediction",
                                   viz_id_, red, green, blue, 1.0);

  // let's do some fitting adventure...
  // since the constraint is enforced at the first point, we need to remove the
  // first point and replace it with the current state estimate...
  TrajectoryPlusPoint state_est_point;
  if (reference_ready_) {
    std::lock_guard<std::mutex> guard(curr_ref_mtx_);
    state_est_point.time_from_start = 0.0;
    state_est_point.position = curr_reference_.position;
    state_est_point.velocity = curr_reference_.velocity;
    state_est_point.acceleration = curr_reference_.acceleration;
  } else {
    state_est_point.time_from_start = 0.0;
    state_est_point.position = temp_state_estimate.position;
    state_est_point.velocity = temp_state_estimate.velocity;
    state_est_point.acceleration = Eigen::Vector3d::Zero();
  }
  traj_world_ext.replaceFirstPoint(state_est_point);

  double fitting_error = 0.0;
  traj_world_ext.fitPolynomialCoeffs(5, 2, &fitting_error);
  traj_world_ext.enableYawing(enable_yawing_);
  traj_world_ext.resamplePointsFromPolyCoeffs();

  traj_world_ext.getTrajectory(&network_traj);
  visualizer_->visualizeTrajectory(network_traj, "fitted_nw_prediction",
                                   viz_id_, red, 1.0, blue, 1.0);
  double desired_speed;
  desired_speed =
      std::min(temp_state_estimate.velocity.norm() + 1.0, test_time_velocity_);
  traj_world_ext.setConstantArcLengthSpeed(
      desired_speed, static_cast<int>(traj_len_), traj_dt_);
  traj_world_ext.getTrajectory(&network_traj);
  visualizer_->visualizeTrajectory(network_traj, "arclen_nw_prediction",
                                   viz_id_, red, 1.0, blue, 1.0);

  viz_id_ += 1;
  if ((viz_id_ - viz_id_start_) >= num_traj_viz_) {
    viz_id_ = viz_id_start_;
  }

  {
    std::lock_guard<std::mutex> guard(nw_pred_mtx_);
    network_prediction_ = traj_world_ext;
  }
  // go into network mode
  if (execute_nw) {
    state_machine_ = StateMachine::kNetwork;
  } else {
    state_machine_ = StateMachine::kExecuteExpert;
  }
}

void ExpertPlanner::odometryCallback(const nav_msgs::OdometryConstPtr& msg) {
  odom_idx_++;
  if (odom_idx_ % process_every_nth_odometry_ == 0) {
    odom_idx_ = 0;
  } else {
    return;
  }
  visualizer_->displayQuadrotor();
  quadrotor_common::QuadStateEstimate state_estimate;
  {
    std::lock_guard<std::mutex> guard(odom_mtx_);
    received_state_est_ = *msg;
    if (!velocity_estimate_in_world_frame_) {
      received_state_est_.transformVelocityToWorldFrame();
    }
    state_estimate = received_state_est_;
  }
  // Push received state estimate into predictor
  state_predictor_.updateWithStateEstimate(state_estimate);
  ros::Time time_now = ros::Time::now();

  if (state_machine_ == StateMachine::kComputeLabels ||
      state_machine_ == StateMachine::kOff) {
    return;
  }

  quadrotor_common::Trajectory reference_trajectory;
  if (!acrobatic_trajectory_.points.empty()) {
    computeReferenceTrajectoryPosBased(
        state_estimate.position, acrobatic_trajectory_, traj_len_ * traj_dt_,
        &reference_trajectory, &reference_progress_abs_);
    //    computeReferenceTrajectory(predicted_state, &reference_trajectory);

    // publish the progress to python
    std_msgs::Int32 progress_msg;
    progress_msg.data = reference_progress_abs_;
    ref_progress_pub_.publish(progress_msg);

    if (translate_reference_) {
      translateReferenceToCurrentPosition(&reference_trajectory,
                                          state_estimate.position);
    }
    ///////////////////////////////////////////////////////////////////
    // publish the reference s.t. the florence baseline knows where to go
    TrajectoryPlusPoint florence_ref_point_ext =
        acrobatic_trajectory_ext_.getPoints().at(std::min(
            static_cast<int>(acrobatic_trajectory_ext_.getPoints().size() - 1),
            reference_progress_abs_ + 150));
    nav_msgs::Odometry goal;
    goal.header.frame_id = "world";
    goal.header.stamp = ros::Time::now();
    goal.pose.pose.position.x = florence_ref_point_ext.position.x();
    goal.pose.pose.position.y = florence_ref_point_ext.position.y();
    goal.pose.pose.position.z = florence_ref_point_ext.position.z();
    goal.twist.twist.linear.x = florence_ref_point_ext.velocity.x();
    goal.twist.twist.linear.y = florence_ref_point_ext.velocity.y();
    goal.twist.twist.linear.z = florence_ref_point_ext.velocity.z();

    goal_pub_.publish(goal);
    ///////////////////////////////////////////////////////////////////

    visualizer_->visualizeTrajectory(reference_trajectory, "nominal_reference",
                                     viz_id_, 1.0, 1.0, 1.0, 1.0);
  }

  if (state_machine_ == StateMachine::kExecuteExpert ||
      state_machine_ == StateMachine::kNetwork) {
    quadrotor_common::ControlCommand control_cmd;
    ros::Time cmd_execution_time = time_now + ros::Duration(ctrl_cmd_delay_);
    quadrotor_common::QuadStateEstimate predicted_state =
        getPredictedStateEstimate(cmd_execution_time, &state_predictor_);

    const ros::Time start_control_command_computation = ros::Time::now();

    // check if we reached the end of the maneuver
    if ((acrobatic_trajectory_.points.back().position - state_estimate.position)
                .norm() < 0.5 ||
        reference_progress_abs_ > (acrobatic_trajectory_.points.size() - 20)) {
      ROS_INFO("Reached end of trajectory.");
      reference_progress_abs_ = acrobatic_trajectory_.points.size() - 1;
      ROS_INFO("Switching to kOff");
      state_machine_ = StateMachine::kOff;
      // publish a message that maneuver is finished
      std_msgs::Bool false_msg;
      false_msg.data = false;
      start_flying_pub_.publish(false_msg);
    }

    if (state_machine_ == StateMachine::kExecuteExpert) {
      // only required if testing 'fitted' expert
      // convert to extended trajectory format
      quadrotor_common::TrajectoryPoint curr_state;
      curr_state.position = predicted_state.position;
      curr_state.velocity = predicted_state.velocity;
      curr_state.orientation = predicted_state.orientation;

      TrajectoryPlus rollout(reference_trajectory, FrameID::World, curr_state);
      rollout.truncateBack(traj_dt_ * traj_len_);
      rollout.enableYawing(enable_yawing_);
      rollout.convertToFrame(nw_predictions_frame_id_, curr_state.position,
                             curr_state.orientation);

      // fit polynomial
      unsigned int poly_order = 5;
      unsigned int continuity_order = 2;
      rollout.fitPolynomialCoeffs(poly_order, continuity_order);
      rollout.resamplePointsFromPolyCoeffs();
      double desired_speed =  // avg_velocity;
          std::min(state_estimate.velocity.norm() + 1.0, test_time_velocity_);
      //      printf("desired speed: %.2f\n", desired_speed);
      //      rollout.setConstantArcLengthSpeed(desired_speed,
      //                                        static_cast<int>(traj_len_),
      //                                        traj_dt_);
      rollout.convertToFrame(FrameID::World, curr_state.position,
                             curr_state.orientation);
      rollout.getTrajectory(&reference_trajectory);
      visualizer_->visualizeTrajectory(reference_trajectory, "fitted_reference",
                                       101, 1.0, 1.0, 0.0);
    } else if (state_machine_ == StateMachine::kNetwork &&
               !network_prediction_.getPoints().empty()) {
      double t_shift =
          std::max(0.0, (time_now - time_received_prediction_).toSec());
      quadrotor_common::Trajectory tmp_ref;
      {
        std::lock_guard<std::mutex> guard(nw_pred_mtx_);
        network_prediction_.getTrajectory(&tmp_ref);
      }
      reference_trajectory.points.clear();

      for (auto point : tmp_ref.points) {
        quadrotor_common::TrajectoryPoint tmp_point = tmp_ref.getStateAtTime(
            point.time_from_start + ros::Duration(t_shift));
        reference_trajectory.points.push_back(tmp_point);
      }
    }

    // feed the reference to the controller
    {
      std::lock_guard<std::mutex> guard(curr_ref_mtx_);
      curr_reference_ = reference_trajectory.points.front();
      prev_ref_traj_ = reference_trajectory;
      t_prev_ref_traj_ = time_now;
      reference_ready_ = true;
    }

    // visualize reference trajectory first
    visualizer_->visualizeTrajectory(reference_trajectory, "control_ref", 0,
                                     0.0, 1.0, 0.0);
    visualizer_->visualizeExecutedReference(
        reference_trajectory.points.front());
    visualizer_->visualizeExecutedTrajectory(*msg);
    //    ROS_INFO("Running base controller with reference: %.2f, %.2f, %.2f",
    //             reference_trajectory.points.front().position.x(),
    //             reference_trajectory.points.front().position.y(),
    //             reference_trajectory.points.front().position.z());
    // we publish the current setpoint for other nodes here
    setpoint_pub_.publish(reference_trajectory.points.front().toRosMessage());
    control_cmd = base_controller_.run(predicted_state, reference_trajectory,
                                       base_controller_params_);
    control_cmd.timestamp = time_now;
    control_cmd.expected_execution_time = cmd_execution_time;
    const ros::Duration control_computation_time =
        ros::Time::now() - start_control_command_computation;

    publishControlCommand(control_cmd);
  }
}

void ExpertPlanner::completedGlobalPlanCallback(
    const std_msgs::BoolConstPtr& msg) {
  if (!msg->data) {
    ROS_WARN(
        "Planner failed, not switching state and waiting for python to restart "
        "things...");
    return;
  }
  ROS_INFO(
      "Global Planner completed! Loading adapted reference trajectory now!");
  quadrotor_common::Trajectory adapted_reference;

  std::string adapted_ref_fname = curr_data_dir_ + "/ellipsoid_trajectory.csv";
  loadReferenceTrajectory(&adapted_reference, adapted_ref_fname, true);

  // check the trajectory
  smoothTrajectory(&adapted_reference, maneuver_velocity_);
  logging_helper_.saveTrajectorytoCSV(adapted_ref_fname, adapted_reference);

  for (auto& point : adapted_reference.points) {
    printf(
        "t: %.2f | Position: %.2f, %.2f, %.2f | Velocity: %.2f, %.2f, %.2f\n",
        point.time_from_start.toSec(), point.position.x(), point.position.y(),
        point.position.z(), point.velocity.x(), point.velocity.y(),
        point.velocity.z());
  }

  acrobatic_trajectory_.points.clear();
  acrobatic_trajectory_ = adapted_reference;
  ROS_INFO("Gogogo!");
  if (only_expert_) {
    // we only go to kExecuteTrajectory mode if we want to execute expert
    // only else we wait for the first trajectory from the network to arrive
    // before switch to kNetwork mode
    ROS_INFO("Switching to kExecuteExpert");
    state_machine_ = StateMachine::kExecuteExpert;
  } else {
    // setting the state machine to kAutopilot here reallows to switch to
    // network later
    ROS_INFO("Switching to kAutopilot");
    state_machine_ = StateMachine::kAutopilot;
  }
  for (int i = 0; i < 1; i++) {
    std_msgs::Bool bool_msg;
    bool_msg.data = true;
    start_flying_pub_.publish(bool_msg);
    ros::Duration(0.05).sleep();
  }
}

quadrotor_common::QuadStateEstimate ExpertPlanner::getPredictedStateEstimate(
    const ros::Time& time, const state_predictor::StatePredictor* predictor) {
  return predictor->predictState(time);
}

void ExpertPlanner::publishControlCommand(
    const quadrotor_common::ControlCommand& control_command) {
  if (state_machine_ == StateMachine::kExecuteExpert ||
      state_machine_ == StateMachine::kNetwork) {
    quadrotor_msgs::ControlCommand control_cmd_msg;
    control_cmd_msg = control_command.toRosMessage();
    control_command_pub_.publish(control_cmd_msg);
    state_predictor_.pushCommandToQueue(control_command);
  }
}

bool ExpertPlanner::loadParameters() {
  pnh_.getParam("data_dir", data_dir_);

  if (!quadrotor_common::getParam("general/velocity_estimate_in_world_frame",
                                  velocity_estimate_in_world_frame_, false))
    return false;
  if (!quadrotor_common::getParam("general/control_command_delay",
                                  ctrl_cmd_delay_, 0.0))
    return false;
  if (!quadrotor_common::getParam("general/num_traj_viz", num_traj_viz_, 100))
    return false;
  if (!quadrotor_common::getParam("general/translate_reference",
                                  translate_reference_, false))
    return false;
  if (!quadrotor_common::getParam("general/perform_global_planning",
                                  perform_global_planning_, false))
    return false;
  if (!quadrotor_common::getParam("general/test_time_velocity",
                                  test_time_velocity_, 1.0))
    return false;
  if (!quadrotor_common::getParam("general/test_time_max_z", test_time_max_z_,
                                  5.0))
    return false;

  int nw_predictions_frame_id;
  if (!quadrotor_common::getParam("general/nw_predictions_frame_id",
                                  nw_predictions_frame_id, 0))
    return false;
  if (!quadrotor_common::getParam("general/real_world_exp", real_world_exp_,
                                  false))
    return false;
  if (!quadrotor_common::getParam("general/process_every_nth_odometry",
                                  process_every_nth_odometry_, 1))
    return false;
  if (!quadrotor_common::getParam("maneuver/idx", maneuver_idx_, 1))
    return false;

  if (!quadrotor_common::getParam("maneuver/n_loops", n_loops_, 1))
    return false;

  if (!quadrotor_common::getParam("maneuver/length_straight", length_straight_,
                                  35.0))
    return false;

  if (!quadrotor_common::getParam("maneuver/loop_radius", loop_radius_, 55.0))
    return false;

  if (!quadrotor_common::getParam("maneuver/maneuver_velocity",
                                  maneuver_velocity_, 1.0))
    return false;
  if (!quadrotor_common::getParam("maneuver/d_start_center_x",
                                  d_start_center_x_, 1.0))
    return false;
  if (!quadrotor_common::getParam("maneuver/d_start_center_y",
                                  d_start_center_y_, 1.0))
    return false;
  if (!quadrotor_common::getParam("maneuver/d_start_center_z",
                                  d_start_center_z_, 0.0))
    return false;

  int traj_len;
  if (!quadrotor_common::getParam("trajectory/traj_len", traj_len, 10))
    return false;
  if (!quadrotor_common::getParam("trajectory/traj_dt", traj_dt_, 0.1))
    return false;
  if (!quadrotor_common::getParam("trajectory/continuity_order",
                                  continuity_order_, 1))
    return false;
  if (!quadrotor_common::getParam("trajectory/enable_yawing", enable_yawing_,
                                  false))
    return false;
  if (!quadrotor_common::getParam("data_generation/save_freq", save_freq_,
                                  10.0))
    return false;

  double pitch_angle_deg;
  if (!quadrotor_common::getParam("camera/pitch_angle_deg", pitch_angle_deg,
                                  0.0))
    return false;
  cam_pitch_angle_ = pitch_angle_deg / 180.0 * M_PI;

  traj_len_ = static_cast<unsigned int>(traj_len);

  switch (nw_predictions_frame_id) {
    case 0: {
      nw_predictions_frame_id_ = FrameID::World;
      break;
    }
    case 1: {
      nw_predictions_frame_id_ = FrameID::Body;
      break;
    }
    case 2: {
      nw_predictions_frame_id_ = FrameID::GravityAligned;
      break;
    }
  }

  return true;
}

}  // namespace expert_planner

int main(int argc, char** argv) {
  ros::init(argc, argv, "expert_planner");
  expert_planner::ExpertPlanner expert_planner;

  ros::MultiThreadedSpinner spinner(4);
  spinner.spin();
  // ros::spin();

  return 0;
}
